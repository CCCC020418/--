##  JS高级
```javascript
        - 高级语言都需要经过编译，代码需要转换为机器码然后由计算机执行
        - 根据编译时机的不同，高级语言又分为两种：
        编译型语言
        - 代码编写完毕立刻进行编译转换为机器码
        然后将机器码交给计算机执行

        - 特点：
        1.运行速度快
        2.兼容性差

        - 例子：
        C、C++ ...

        解释型语言
        - 代码编写完毕不会转换为机器码，
        而是由计算机一边执行一边编译

        - 特点：
        1.运行速度慢
        2.兼容性好

        - 例子：
        Java、Python、Ruby、JavaScript ...


        Js代码需要编写在script标签中
        //<script>
        输出型
        alert（）用来在窗口弹出一个警告框、
        console.log( )用来在控制台输出一个日志

        document.write()
        用来向网页中输出一个内容

        字面量
        字面量表示的是一个值，他所表示的意思就是它的字面意思
        字面量可以在js中直接使用，但是通常不会这么做
        变量
        变量可以用来储存字面量，一个变量可以存储任意类型的字面量
        我们一般都是通过变量去存储字面量而不是直接使用字面量
        变量的使用
        声明变量
        使用let关键字来声明变量




        标识符
        在程序中所有可以自主命名的内容都可以认为是标识符
        比如：变量名，函数名，类名
        标识符需要遵顼如下规范
        1.标识符中可以含有字母，数字，-，￥，但是不能以数字开头
        2.标识符不能是JS中的关键字和保留字，也不建议使用JS中内置的函数名和变量名
        3.标识符应该遵循驼峰命名法
        驼峰命名法
        首字母小写，每个单词开头字母大写


        数据类型（值的类型）
        字符串(string)
        JS中的字符串需要使用引号引起来，
        单引号和双引号都行但是不能混合使用
        引号不能跨行使用，同类型的引号不能嵌套
        JS中使用\作为转义字符
        \' 表示 '
        \" 表示 "
        \n 表示 换行
        \t 表示 制表符
        \\ 表示 \
        模板字符串（老版本的浏览器不支持）
        - 使用反单引号 //` 来创建模板字符串
        - 特点：
        1.可以换行，并保留字符串中的格式
        2.在模板字符串中可以直接嵌入变量
        变量的语法 ${变量}
        在JS中，所有数值包含整数和浮点数（小数）都属于number类型
        在JS中可以确保大部分的整数运算得到一个精确的结果
        在JS中，小数运算有可能得到一个不精确的结果
        所以，在JS中不用直接对精度要求高的运算(尤其是钱）
        当数值超过一定范围后，会使用INFINITY来表示
        infinity是正无穷
        NaN也是一个特殊数字，表示Not  a Number  非法数字




        布尔值（boolen)
        布尔值用来进行逻辑判断
        let bool = true  真
        let =false    假
        使用typedf检查一个布尔值会返回boolean

        空值和未定义
        null 通常用来表示一个空的对象，一个不存在的东西
        null只有一个值  就是  null
        使用typeof检查一个null时，它会返回 object
        undefined 表示未定义 ，当我们定义一个变量但是不赋值时他就是undefined
        undefined类型的值只有一个，就是undefined
        使用typeof检查一个undefined时，会返回‘undefined’
        一般我们不会主动使用undefined
        基本数据类型是构成我们整个JS世界的基石
        数值(number)
        字符串(string)
        布尔值（boolean）
        空值（null）
        未定义(undefined)


        类型转换，指将其他的数据类型转换string，
        将其他的类型转换为字符串
        方式一
        调用被转换类型的ToString()方法
        调用xxx的yyy方法————>xxx.yyy( )
        由于null和undefined中不含有tostring
        方法二
        调用string（）函数，来将被转换类型换为字符串
        -调用xxx函数--->xxx（）
        -原理：
        对于具有tostring（）方法的值，就是直接调用tostring()对其进行转换，
        但是对于null来说，他是直接将其转换为‘null’
        undefined 直接转换为'undefined'
        调用tostring(),将10转换为字符串
        a=a.tostring（）;
        调用string()函数来将其他类型转换为字符串
        其他类型转换为数字
        使用number()函数来将一个其他类型转换为数字
        转换的情况：
        字符串：
        如果字符串是一个合法数字，则直接转换为对应的数字
        如果字符串不是一个合法的数字，则转换为nan
        布尔值
        true-->1
        false-->0
        null-->0
        undefined-->NaN

        除了Number()以外。
        还有两个函数是专门用来将一个字符串转换为数字的
        parseInt()
        -将一个字符串解析为一个整数
        -该函数会自左向右依次读取一个字符串中的字符
        直到找到字符串中所有的合法整数为止
        -还可以用来对一个数字进行取整
        ParseFloat（）
        -将一个字符串解析为一个小数
        其他类转换为布尔值
        使用Boolean()函数来将其他类型转换为布尔值
        -对所有表示没有错误的都会转换为false
        -对于数值；
        除了0和NaN,都是true
        -对于字符串：
        空串是false,其他都是true
        -null和undefined都是false
        -一般情况对象都会转换为true


        -false的情况
        0，NaN.''.false,null,undefined



        运算符（操作符）
        -通过运算符可以对一个值或多个值进行各种运算
        -对一个值进行运算的运算符，称为一元运算符
        对两个值进行运算，叫做二元运算符
        以此类推




        -算术运算赋
        +对两个值进行加法运算
        —对两个值进行减法运算
        *对两个值进行乘法运算
        /对两个值进行除法运算
        **（幂运算）求一个值的几次幂
        %（取模） 两个数相除取余数



        如果对于两个字符串做加法运算，则会将两个字符拼接为一个
        除了字符串的加法以外，对其他类型的值进行算数运算时
        都会转化为数值然后再进行运算


        所以我们可以通过为一个任意值 -0 ，*1 等方式来将其转换为数字
        这种方式称为隐式类型转换，它的原理是和Number（）函数一样
        但是更简单一些


        任何值和NaN做任何运算结果的都是NaN（除了字符串加法）
        、




        字符串的加法
        任何值和字符串做加法时都会转换为字符串
        然后再和字符串进行拼串


        利用这特点，可以通过为一个任意值 加上一个空串（‘’）的形式
        来将其转换为字符串，它的原理和String（）函数是一样的
        但是这种方式要简单一些


        typeof
        -检查一个值的类型
        +
        -一元的+（正号）
        -不会对数值进行任何影响
        -

        - 一元的-（负号）
        -会对数值进行符号位取反

        -对于分数值类型的值进行正负运算时
        他会先将其转换为数值然后再运算

        -利用一元的+，可以将一个任意类型的值转换为数值
        原理同Number（）函数，但是更加的简单

        自增和自减
        自增（++）
        -自增分为前++（++a）   和后++（a++）
        -无论是++a还是a++，对于a来说都是一样的
        都会使变量a立刻增加1
        -   a++ 和 ++a 的返回结果不同
        a++   返回的变量自增前的值，旧值
        ++a   返回的是变量自增后的值，新值


        自减（--）
        -自减分为前--（--a） 和后--（a--）
        -无论是--a还是a--都会是变量a立刻自减一
        -不同点在于 --a 和 a-- 的值不同
        --a是自减后的值，新值
        a--是自减前的值，旧值




        赋值运算符
        -用来将一个值赋值给一个变量
        =
        - =号用于将符号右侧的值赋值给左侧的变量
        +=
        -  a  +=  x  等价于 a = a + x
        -=
        -  a  -=  x  等价于 a = a - x
        *=
        -  a  *=  x  等价于 a = a * x
        /=
        -  a  /=  x  等价于 a = a / x
        **=
        -  a  ** = x  等价于 a = a ** x
        %=
        -  a  %  = x  等价于 a = a % x


        那些情况会导致变量法合适呢个变化（ 为变量进行重新赋值）：
        1. 对变量使用赋值运算符
        a = xx
        a += xx
        a -= xx
        ...
        2. 对变量使用自增自减
        a++
        ++a
        a--
        --a

        逻辑运算符
        ！ 逻辑非
        -！可以对一个值进行非运算 （ 取反操作）
        - 如果值是true，则变成false，false变成true
        - 如果对一个非布尔值进行逻辑非运算
        他会先将其转换为布尔值，然会再取反


        - 利用这一点，可以对一个任意值
        取两次反来将其转换为布尔值
        原理和Boolean（）函数一样


        &&   逻辑与
        ||   逻辑或




        &&  逻辑与
        *       - 可以对符号左右两侧的值进行与运算
        *       - 如果两侧的值都是true，则返回true，否则返回false
        *       - 与运算是找false的
        *       - 与运算是短路的与
        *           如果第一个值是否false，则不会去看第二个值
        *
        *  ||  逻辑或
        *       - 可以对符号两侧的值进行或运算符
        *       - 如果两侧有一个true，就返回true，否则返回false
        *       - 或运算是找true
        *       - 或运算是短路的或
        *           如果第一个值是true，则不会看第二个值
        * */




        与运算：
        - 如果对非布尔值进行与运算，
        会首先将其转换为布尔值，然后运算，最终返回原值
        - 如果第一个值是true，则返回第二个值
        如果第一个值是false，则返回第一个值

        或运算
        - 如果第一个值是true，则直接返回第一个，否则返回第二个

        与找false，或找true
        关系运算符
        特殊情况：
        -当比较运算符的两侧都是字符串时，他不会将其转换为数字进行比较
        而是逐位比较字符串的字符编码
        利用这个特点可以对一个字符串按照字母顺序进行排序
        相等运算符
        ==
        -相等运算符用来比较两个值是否相等
        -相等运算符会对值进行自动的类型转换
        如果比较的两个值的类型不同，会将其转换为相同的类型然后再比较
        通常情况下，不同类型都会转换为number然后再比较
        null 和undefined 做相等比较时，会返回true

        === （全等）
        -全等用来检查两个值是否全等
        -全等运算不会发生自动的类型转换，
        如果两个值的类型不同，直接返回false


        ！=（不相等）
        -比较两个值是否不全等
        -如果不全等返回true，全等返回false
        -不会做自动的类型转换，如果两个值的类型不同，直接返回true

        检查一个值是否时NaN时，需要使用函数is NaN（）
        console.log(isNaN(a));
        条件运算符（三元运算符，三目运算符）
        -语法；
        条件表达式？语句1：语句2
        -执行流程：
        条件运算符在执行时，会先对条件表达式进行求值判断，
        如果判断结果为true，则执行语句1
        如果判断结果为false，则执行语句2
        false ?  alert(`语句1`) : alert(`语句2`)；

        运算符的优先级
        和数学运算一样，JS中运算符也有优先级的问题
        比如：先乘除后加减
        运算符的优先级根据运算符优先级表来决定
        在表中，位置越靠上的优先级越高，优先级越高越优先计算
        优先级一样，按照从左向右的顺序以此计算
        优先级的表不需要记忆，遇到优先级不清的，可以通过（）来改变优先级
        代码块
        在JS中我们使用{}来为代码进行分组，
        一对大括号就是一个代码块，
        同一代码块中的代码要么都执行，要么都不执行
        代码块中使用let声明的变量，在代码块外部无法访问
        但是  使用var 声明得变量没有块作用域，在代码块的外部也可以访问
        流程控制语句
        代码默认是按照自上向下的顺序一行一行执行的
        但是仅仅是这样，并不能满足我们开发的需要
        可以通过流程控制语句来改变程序执行的顺序
        条件判断语句
        条件分支语句
        循环语句


        条件判断语句

        语法：
        if（条件表达式）{
        语句。。。
        }
        执行流程：
        if语句在执行时，先对条件表达式进行求值判断
        如果结果为true，则执行if后的语句
        如果结果为false，则不执行


        if语句默认只会控制紧随其后的那条语句
        对于我们来说，最佳实践是，即使if后仅有一条语句，最好也使用{}


        如果条件表达式的结果是一个非布尔值，会转为布尔值进行判断


        if语句
        if-else 语句
        if（条件表达式）{
        语句...
        }else{
        语句...
        }
        执行流程：
        if-else 执行时，先对if后的条件表达式进行求值判断
        如果为true，则执行if后的语句
        如果为false， 则执行else后的语句

        if-else  if-else语句
        if（条件表达式）{
        语句...
        }else if (条件表达式）{
        语句...
        }else if (条件表达式){
        语句...
        }else{
        语句...
        }
        执行流程：
        if-else if-else语句在执行时，
        它会自上向下依次对if后的条件表达式进行求值判断
        如果判断结果为true，则执行当前if后的语句，执行完毕语句结束了
        如果判断结果为false，则继续向下判断，直到找到true为止。
        如果所有的判断结果都是false，则执行else后的语句
        if-else if-else 语句中，只会有一个代码块执行，
        代码块执行后，其他语句不会再判断，语句立即结束

        循环语句
        - 循环语句可以让指定的代码反复执行多次
        - 循环有三种
        while语句
        do-while语句
        for语句

        while语句
        while(条件表达式){
        语句...
        }

        执行流程
        while语句在执行时，会先对条件表达式进行求值判断
        如果结果为false，则语句直接结束
        如果结果为true，则执行while后的代码（循环体）
        执行完毕，继续对条件表达式进行求值判断，以此类推



        条件表达式恒为true的循环，叫做死循环，会一直执行下去（慎用）
        while(true){
        alert('hello');
        }

        循环的三个要件

        初始化表达式，创建一个变量来控制循环的执行
        let i = 0;

        条件表达式，设置循环的执行条件
        while(i < 10){
        console.log(i);
        更新表达式，修改初始化变量
        i++;
        }
        - do-while循环
        do{
        语句..
        }while (条件表达式)

        - 执行流程：
        do-while循环在执行时，会先执行循环体，
        执行完毕对条件表达式进行求值判断
        如果为false，则语句结束
        如果为true，则继续执行循环体
        以此类推

        do-while是先执行后判断，while是先判断后执行
        do-while可以确保循环至少一次，其他的时候和while没有区别
        for循环
        -语法：
        for（①初始化表达式；②条件表达式；④更新表达式）{
        ③语句...
        }

        -执行流程：
        for循环在线执行是；
        ①先执行初始化表达式，初始化一个变量（只会执行一次）
        ②执行条件表达式，判断循环是否执行
        如果为false，则循环结束
        ③如果为true，则执行循环体
        ④执行更新表达式对变量进行更新
        ⑤重复②


        当循环发生嵌套时，外层循环每执行一次，内层循环就执行一圈


        创建一个循环来控制图形的高度
        for(let i=0; i<5; i++){
        创建一个内层循环来控制图形的宽度
        for(let j=0; j<5; j++){
        document.write('*&nbsp;&nbsp;');
        }
        document.write('<br>');
        }

        break
        -break用来结束switch和循环语句
        -break默认只会影响到离他最近的循环

        continue
        -continue用来跳过当次循环


        基本数据类型（不可变类型）
        -Number
        -string
        -boolean
        -null
        -undefined


        对象（object）
        -对象就是JS中的一种数据类型
        -基本数据类型都是一个一个个独立的值
        值与值之间不存在任何的联系
        这样就导致我们无法在程序中来表示一些复杂的数据

        -对象相当于是一个容器(复合数据类型)，在对象中可以存储不同类型的数据
        对象中存储的数据被称为属性，向对象中添加数据成为添加属性
        当我们访问一个对象中没有的属性时，不会报错而是返回undefined
        属性
        属性名：
        对象的属性是任意值，不必须遵守标识符的规范
        但是如果你起的名字太特殊，必须采取另外的方式进行命名：
        对象[`属性名`]   = 属性值
        虽然如此，属性名尽量要遵循标识符的规范
        读取属性的第二种方式：
        对象[`属性名`]
        - 这种方式读取属性更加灵活
        属性值：
        对象的属性值可以是任意的数据类型
        大括号创建
        <script>
        'use strict'; //使用strict模式

        /**
        使用{}创建对象，等同于 new Object();
        **/
        var o = {};

        o.name = 'jack';
        o.age = 20;

        o.sayName = function(){
        alert(this.name);
        }

        alert(o.name+'-'+o.age);

        o.sayName();

        </script>


        通过new Object()创建对象



        <script>
        'use strict';
        // 使用 new Object() 创建对象
        var o = new Object();
        o.name = "zhangsna";
        o.sayName = function(){
        alert(this.name);
        }

        o.sayName();

        alert('o instanceof Object>>>>>>>>>>>'+(o instanceof Object));//true
        alert("typeof o >>>>> "+typeof o);//object
        </script>


        使用字面量创建对象
        对象字面变量是对象定义的一种简写形式,举个例子：
        var person = {name: 'zhang', age:20}， 这就是字面量形式，完全等价于var person = {}; person.name='zhang'; person.age=20;
        。




        四、使用工厂模式创建对象
        这种方式是使用一个函数来创建对象，减少重复代码，解决了前面三种方式的代码冗余的问题，但是方法不能共享的问题还是存在。




        <script>
        'use strict';

        // 使用工厂模式创建对象
        // 定义一个工厂方法
        function createObject(name){
        var o = new Object();
        o.name = name;
        o.sayName = function(){
        alert(this.name);
        };
        return o;
        }

        var o1 = createObject('zhang');
        var o2 = createObject('li');

        //缺点：调用的还是不同的方法
        //优点：解决了前面的代码重复的问题
        alert(o1.sayName===o2.sayName);//false

        </script>


        通过构造函数创建对象
        所谓构造函数，也是普通的函数，不过约定俗成，构造函数的名称首字母大写，普通函数的首字母小写。通过new 构造函数来创建对象。




        <script>
        'use strict';

        /**
        *  构造函数模式创建对象
        **/
        function Person(name){
        this.name = name;
        this.sayName = function(){
        alert(this.name);
        };
        }

        var p1 = new Person('zhang');
        var p2 = new Person('li');

        p1.sayName();
        p2.sayName();

        alert(p1.constructor === p2.constructor);//true
        alert(p1.constructor === Person);//true

        alert(typeof(p1));//object

        alert(p1 instanceof Object); //true
        alert(p2 instanceof Object); //trueb

        alert(p1.sayName===p2.sayName);//false

        </script>

        。



        可变类型
        当一个变量的值被修改时，只会影响他自己，对其他变量不会产生任何影响
        当我们对对象进行修改时（改对象），如果有其他的变量同时指向该对象
        则也会被影响到
        该变量对其他变量不会有影响
        变量= xxx
        变量+= xxx
        变量++
        该对象会影响到其他指向该对象的变量
        变量，属行 = xxx
        比较两个对象时，无论是相等还是全等比较都是对象的内存地址
        声明常量是禁止修改变量，不会影响到我们修改对象



        对象
        比较两个对象时  无论是全等还是相等比较都是对象的内存地址
        声明常量是禁止修改质量，不会影响我们修改对象




        检查一个对象中是否含有某个属性
        in  运算符  用来检查对象中是否含有某个属行
        有返回true ， 没有返回false
        语法：
        `属行名`  in  对象


        console.log(`name` in obj );


        for-in  用来对对象中的属行进行枚举，就是将对象中属行全都取出来
        语法：
        for(let 变量  in  对象){
        语句...
        }


        for-in会执行多次，对象中有几个属性就会执行几次，
        每次执行都会将一个属性名赋值我们定义的变量




        对象字面量
        - 以字面量的形式来创建对象
        - 可以之间使用{}来创建一个对象
        -使用typeof检查一个对象时  会返回`object`

        -字面量可以在创建对象时直接向对象中添加属性
        -语法：
        {
        属性名：属性值
        属性名：属性值
        属性名：属性值

        }



        函数（function）
        - 函数也是一个队型和其他的对象功能一样
        - 不同的是在函数中可以存储JS代码，
        并且可以在我们需要的时候对这些代码进行反复地调用


        打印函数对象
        consol.log(fn)
        调用函数 函数对象（）调用函数就是执行函数中存储的代码
        fn（）；
        函数表达式；
        let fn2 = function（[形参1，形参2，.....形参N]）{
        语句...
        }；
        fn2（）；
        定义一个函数可以用来求任意两个数的和


        形参（形式参数）：
        - 在定义函数时，可以在函数的（）中指定数量不等的形参
        - 定义形参就相当于在函数中声明了两个变量
        但是没有赋值
        实参（实际参数）：
        -  再调用函数时，可以在函数的（）中传递数量不等的实参
        实参将会赋值给对应的形参
        -  JS中不会检查实参的类型和数量
        -可以传递任意类型的实参
        -也可以传递任意数量的实参
        如果实参和形参的数量相同，则对应的实参赋值给对应形参
        如果实参少于形参的数量，则没有实参的形参默认为undefined
        如果实参多余形参，则多余的实参不会使用

        返回值：
        -  返回值就是函数的执行结果
        -   通过return来设置函数的返回值
        语法：return  值：
        -  任何值都可以作为函数的返回值
        -  如果不设置return 或  return  不跟任何值
        则相当于 return  undefined
        -   return  后的所有代码都不会执行
        return 执行后  函数立即结束

        调用函数时，返回值就是函数的执行结果，可以定义一个变量来接受结果

        使用typeof检查一个函数时，会返回function
        任何值都可以成为对象的属性，函数也不例外
        如果一个对象的属行时函数，
        则我们称这个函数是这个对象的方法（method）
        调用函数就称为调用xx对象的xx方法

        函数和方法目前来讲只是称呼的不同，没有本质区别


        作用域（scope）
        -  作用域指的就是变量的作用范围
        -  作用域分为两大类：
        全局作用域
        局部作用域
        -  块作用域
        -  函数作用域


        -全局作用域（global）
        - 全局作用域在页面加载时创建，在页面关闭时销毁
        -  所有的直接写在script 标签中的内容，都位于全局作用域中
        -  全局作用域中定义的变量是全局变量，定义的函数是全局函数
        全局变量和全局函数可以在任意位置被访问到
        -  全局作用域中存在有一个全局对象 window，window对象代表浏览器窗口
        在全局作用域中，所有的使用var声明的变量，都会作为window
        对象的属性值
        使用function 声明的函数都会作为window对象方法保存
        函数实际上就是window对象的方法！

        -let声明的变量不会存储在window对象中
        在JS中，使用var声明的变量
        会在所有的代码执行前被创建，但是不会赋值
        所以我们可以在变量声明前就对其进行访问
        这个特点称为变量的提升
        使用function开头的函数，会在所有代码执行前被创建
        所以我们可以在函数声明前就对其进行调用
        这个特点成为函数的提升！
        函数作用域：
        - 函数作用域在函数调用时创建，调用结束时销毁
        - 函数每次调用都会产生一个新的函数作用域
        每个作用域间是相互独立的
        - 在函数作用域中声明的变量是局部变量
        局部变量只能在函数内部访问，外部无法访问
        注意：在函数中声明变量时如果不使用var或let
        则变量会变成全局变量（一定要注意！！！）
        -在函数作用域中可以访问全局作用域的变量
        但是在全局作用域中无法访问函数作用域的变量
        -  变量和函数的提升，在函数作用域中同样适用
        作用域链：
        当我们访问一个变量时，js会现在当前作用域中寻找
        如果有则直接使用
        如果没有，则去当前作用域的上一层作用域寻找
        找到了则直接使用，没找到继续去上一层寻找，以此类推
        直到找到全局作用域，如果没有找到则报错xxx is not  defined

        JS中的作用域叫做  词法作用域，简单说，函数作用域由它定义的位置来决定的
        和调用位置无关。
        函数的定义在哪，他的上一层就是哪

        对象
        可以通过  构造函数  来创建对象
        - 构造函数就是专门用来创建对象的函数
        -构造函数的定义方式和普通函数没有区别
        唯一的不同点在于构造函数的名字首字母要大写
        - 构造函数和普通函数的区别在于调用的方式
        一个函数如果直接调用，那么他就是一个普通函数
        如果使用new关键字调用，他就是一个构造函数
        - 一个构造函数也称为是一个类，通过该构造函数所创建的对象
        称为该类实例，通过同一个类创建的对象，称为同一类对象
        构造函数的执行流程：
        1。创建一个新的对象
        2. 将这个新的对象设置为函数中的this
        3. 执行函数中的代码
        4. 将新建的对象返回


        构造函数
        现在我们的方法直接定义在了构造函数中
        也就是构造函数，每执行一次，就会创建一个新的函数对象
        这样也就意味着，每一个对象都有不同的sayhello（）方法
        但是，这些sayhello（）的功能却是一样的
        而创建许多会占用大量的内存空间，实际完全可以所有的对象都公用seyhello（）


        原型
        每个函数对象中都有一个属行叫做prototype
        该属性指向的是一个对象，这个对象原型对象
        如果函数作为普通函数调用，那么通过该构造函数所创建的对象中
        都会有一个隐含的属行（__proto__）指向函数的原型对象（prototype）
        也就是说，该类的所有实例中都会有一个隐含属性指向构造函数的prototype，
        原型对象，就相当于一个公共的区域可以被所有的该类实例访问
        可以将一些实例共有的属性或方法存储在原型对象中
        这样只需要设置一次即可让所有的对象都访问到该属行



        当我们访问一个对象中的属性时，JS会现在对象本身中寻找，
        如果找到了则直接使用
        如果没有找到则取对象的原型(__proto__)中寻找，
        找到了则使用


        结论：
        定义一个类时，如果属行和方法是对象独有的，就直接在构造函数中设置
        function  类名(){
        this.xxx = yyy;
        }

        如果属行和方法是公共的，每一个对象的值都是相同，可以通过原型来添加
        类.prototype.属性名 = 值；
        需要记住的
        1.定义类时，独有的属行（方法）在构造函数中通过this添加
        2.公共的方法（属行）在构造函数外部通过原型来添加
        3.当我们使用一个对象的属性或方法时，
        JS会先在对象中找，对象中没有去原型中找，
        原型中没有，去原型的原型中找，直到找到object的原型，没有返回undefined



        对象
        1.内建对象
        - 由ES标准所规定的对象
        - Object Function String Boolean Number  Array  Math Date JSON.
        ..
        2.宿主对象
        - 由JS运行环境所提供的对象
        - Window  Console Document ...
        3.自定义对象
        -由开发人员自己定义对象
        数组（Arrgy）
        - 数组也是一个对象
        - 数组用来存储一组有序的数据
        - 数组中存储的数据，称为 元素 （ element）
        数组元素会根据存储的顺序保存在数组之中
        - 数组中的每一个元素都有一个唯一的索引（index）
        索引就是一组以0开始的整数
        第一个元素索引为0，第二个元素索引为1，以此类推
        向数组中添加元素：
        语法：
        数组[索引] = 值
        读取数组中的元素：
        语法：
        数组[索引]
        若获取数组中没有的元素，不会报错而是返回undefined


        属行：
        length  用来获取数组中元素的数量
        它的值实际上是数组的最大索引+1
        向数组的最后的位置添加元素
        数组[数组 .length] =值；
        length属行可以被修改
        - 如果将length改小，则后边的元素会被删除
        - 如果将length改大，后边会多余空的元素
        数组
        - 使用[] 来创建一个数组，和new Array()效果一致
        - 可以在创建数组时，同时像数组中添加元素


        数组中可以存储的数据类型
        -  虽然数组里可以存储任意的数据类型，并且长度没有限制
        但是我们在使用数组，要尽量确保数组中的数据类型是相同

        如果一个数组中的元素还是数组，则这个数组被称为二维数组
        遍历，指的就是获取到数组中的所有元素


        push()
        - 用来向数组的最后添加一个或多个元素
        会返回新的长度

        pop()
        -从数组的最后删除一个元素并返回被删除的元素
        unshift()
        -向数组的前边添加一个或多个元素，并返回新的长度
        shift()
        - 删除并返回数组的第一个元素
        数组的方法
        slice()(非破坏性的方法)
        -slice用来裁取数组
        - 参数：
        1.裁取的起始位置索引(包含起始位置)
        2.裁取的结束位置索引(不包含结束位置)
        -该方法不会影响到原来的数组，而是将结果作为返回值返回
        - 可以省略第二个参数，如果不写第二个参数，则会一直裁取到最后
        - 索引可以传负值 -1 表示倒数第一个 -2 表示倒数第二个，以此类推


        splice()(破坏性的方法)
        - splice可以用来删除，替换，添加数组中的元素
        - 该方法会对原数组产生影响
        - 参数：
        1.删除元素起始位置索引
        2.删除的数量
        3.可以传递多个参数，这些参数将会作为新元素
        添加到数组中
        -返回值：
        被删除的元素






        - 数组
        - forEach()
        - 用来遍历数组
        - 用法：
        需要一个回调函数作为参数，回调函数会反复调用多次
        每次调用时，将遍历到的信息以参数的形式传递
        - 参数：
        1.element 当前遍历到的元素
        2.index 当前元素的索引
        3.array 当前遍历的数组对象

        - concat()
        - 用来连接两个或多个数组

        - join()
        - 用来将数组中的所有的元素连接为一个字符串
        - 参数：
        需要一个连接符作为参数，默认为","

        - indexOf()
        - lastIndexOf()
        - 用来查询元素在数组中出现的位置
        - 参数：
        1.要查询的元素
        2.查询的起始位置
        - 返回值：
        indexOf() 返回元素第一次出现的位置
        lastIndexOf() 返回元素最后一次出现的位置
        如果没有找到，返回-1

        - reverse()
        - 用来反转数组，会影响到原数组

        - sort()
        - 用来对数组进行排序，默认按照Unicode编码进行排序
        - 可以通过回调函数来指定排序规则：
        - 升序：
        function(a, b){
        return a - b;
        }

        - 降序：
        function(a, b){
        return b - a;
        }

        - 回调函数（callback）
        - 由我们定义，但是不由我们调用的函数被称为回调函数

        - 函数（function）
        - arguments
        - arguments是函数中一个隐含的参数，它是一个类数组对象
        函数执行时，所有的实参都会存储到arguments中
        通过它，即使不定义形参也可以直接使用实参

        - call() 和 apply()
        - 它们都是函数的方法，它们可以用来指定函数的this
        它们的第一个参数会成为函数中的this
        - 不同点在于：
        call()的实参是一个一个传递的
        apply()的实参是通过数组来传递
        - 例子：
        fn.call(...);
        fn.apply(...);

        - 递归：
        - 递归就是函数自己调用自己
        - 递归的核心就是对问题的分解，将一个大问题拆分一个一个的小问题
        - 递归两个要点：
        1.基线条件，递归停止条件
        2.递归条件，如果分解问题

        Math
        - Math是一个用来进行数学运算的工具类
        - 工具类不需要创建对象，可以直接使用
        - 在Math中包含了一组数学运算相关的常量和方法
        - 例子：
        Math.PI 获取圆周率
        Math.abs()
        - 获取一个数的绝对值
        Math.ceil()
        - 对一个数向上取整
        Math.floor()
        - 对一个数向下取整
        Math.round()
        - 对一个数进行四舍五入取整
        Math.random()
        - 生成一个0-1之间的随机数
        Math.pow(x, y)
        - 求x的y次幂
        Math.sqrt()
        - 求一个数的平方根（开方）
        Math.max()
        - 取多个值中的较大值
        Math.min()
        - 取多个值中的较小值

        Date
        - Date是表示日期的对象，在JS中所有的时间相关的都使用Date来表示
        - 创建对象：
        1.创建一个表示当前日期的对象
        let d = new Date();
        2.创建一个指定日期的对象
        let d = new Date('月/日/四位年 时:分:秒');
        - 对象的方法：
        d.getDay()
        - 获取当前是周几
        - 返回值 0-6
        d.getDate()
        - 获取当前是几日
        d.getMonth()
        - 获取当前是几月
        - 返回值 0-11
        0 1月
        1 2月
        ...
        d.getFullYear()
        - 获取当前的年份
        ....

        d.getTime()
        - 获取当前日期的时间戳
        Date.now()
        - 获取当前的时间戳（代码执行这一刻）

        包装类
        - JS中提供了三个包装类String、Number、Boolean
        - 包装类可以用来创建基本数据类型的对象，但是我们自己千万不要用
        - 当我们调用字符串、数值、布尔值的方法或属性时，
        浏览器会调用包装类临时将其转换为对象，然后调用对象的属性或方法
        String
        - 字符串的方法
        - 字符串本质上就是一个字符数组
        - 'abc' ---> ['a', 'b, 'c']
        - 字符串的方法：
        str.length
        - 获取字符串的长度
        str.charAt()
        - 根据索引获取指定位置的字符
        str.charCodeAt()
        - 根据索引获取指定位置的字符编码
        String.fromCharCode()
        - 根据字符编码返回字符
        str.indexOf()
        - 查询子串在字符串中第一次出现的位置
        str.lastIndexOf()
        - 查询子串在字符串中最后一次出现的位置
        str.slice()
        - 截取字符串
        str.trim()
        - 去除前后空格
        str.trimEnd()
        - 去除结束的空格
        str.trimStart()
        - 去除开始的空格
        str.startsWith()
        - 检查字符串是否以指定内容开头
        str.endsWith()
        - 检查字符串是否以指定内容结尾
        str.toUpperCase()
        - 将字符串转换为大写
        str.toLowerCase()
        - 将字符串转换为小写
        str.split()
        - 将一个字符串拆分为一个数组

        DOM
        - Document Object Model
        - 文档对象模型
        - 在DOM中为我们提供了一组对象，通过这些对象可以完成对网页的各种操作
        - 文档（Document）
        - 网页就是文档
        - 对象（Object）
        - 在网页中一切都是对象
        - 模型（model）
        - 模型用来体现文档间的关系
        - 在浏览器中，document已经为我们提供好了，可以直接使用，
        document是整个DOM树中最顶级的对象
        通过document可以获取到其他的任意对象
        事件（event）
        -  事件就是用户和网页的交互瞬间
        例如： 点击鼠标，点击按钮，鼠标移动，键盘按下...
        - 我们通过响应用户的事件来完成和用户的交换

        在script标签中，通过JS代码来设置事件的响应
        可以通过为指定对象的事件属行设置响应函数的形式来处理事件
        在事件发生时触发的函数称为事件的响应函数
        网页中的代码在加载时，是







        - DOM的增删改
        - 创建元素
        - document.createElement(标签名)
        - 创建一个新的元素
        - document.createTextNode(文本内容)
        - 创建一个新的文本节点

        - 插入元素
        - 父节点.appendChild(子节点)
        - 向父节点中插入一个子节点

        - 元素.insertAdjacentElement('位置', 元素);
        - 向元素的指定位置插入子元素
        - 元素.insertAdjacentHTML('位置', 'HTML代码');
        - 向元素的指定位置插入HTML代码
        - 元素.insertAdjacentText('位置', '文本内容');
        - 向元素的指定位置插入文本内容
        - 位置需要传递一个字符串作为参数：
        'beforebegin' 开始标签前，成为当前元素的前一个兄弟元素
        'afterbegin' 开始标签后，成为当前元素的第一个子元素
        'beforeend' 结束标签前，成为当前元素的最后一个子元素
        'afterend' 结束标签后，成为当前元素的后一个兄弟元素

        - 父节点.replaceChild(新节点, 旧节点)
        - 使用新节点替换旧节点
        - 父节点.insertBefore(新节点, 旧节点)
        - 将新节点插入到旧节点的前边

        - 复制节点
        - 节点.cloneNode()
        - 对节点进行浅复制（只复制节点本身）
        - 节点.cloneNode(true)
        - 对节点进行深复制（复制节点本身及所有的后代节点）

        - 删除元素
        - 子节点.parentNode.removeChild(子节点)
        - 子节点.remove()

        - this
        - 根据函数的调用方式不同，this的值也不同：
        1.以函数形式调用，this是window
        2.以方法的形式调用，this是调用方法的对象
        3.以构造函数的形式调用，this是新建的对象
        4.以call和apply的形式调用，this是它们的第一个参数
        5.箭头函数中的this由它外层作用域决定
        6.事件的回调函数中，this是绑定事件的对象

        - 默认行为
        - 默认行为指当事件触发时元素默认会做的事情
        比如：点击超链接后页面会发生跳转，点击表单的提交按钮后页面发生跳转 ...
        - 有时默认行为会影响到正常功能，需要将其取消，只需要在事件的响应函数中return false即可取消
        - 例子：
        link.onclick = function(){
        ...
        return false;
        };



        冒泡排序
        function bubbleSort(arr) {
        var i = arr.length, j;
        var tempExchangVal;
        while (i > 0) {
        for (j = 0; j < i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
        tempExchangVal = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = tempExchangVal;
        }
        }
        i--;
        }
        return arr;
        }

        var arr = [3, 2, 4, 9, 1, 5, 7, 6, 8];
        var arrSorted = bubbleSort(arr);
        console.log(arrSorted);
        alert(arrSorted);
        控制台将输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]
        并且弹窗；





        通过JS去操作CSS：
        - 操作内联样式
        - 属性：style
        - 读取样式：
        元素.style.样式名
        - 设置样式：
        元素.style.样式名 = 样式值
        - 注意：
        1.通过style属性所读取和设置的样式都是内联样式
        2.所以通过它所设置的样式通常会立即生效
        3.如果样式名不符合标识符的规范，需要对样式名就行修改：
        去掉-，-后的字母大写
        background-color ==> backgroundColor
        border-left-width ==> borderLeftWidth

        - 获取当前的生效的样式
        getComputedStyle()
        - 参数：
        1.要获取样式的元素
        2.要获取的伪类（没有可以不写）
        - 返回值：
        一个对象，对象中包含了当前元素所有生效的样式

        - 注意：
        该方法获取的样式全都是只读的，无法修改

        - 其他的样式相关的属性：
        clientWidth
        clientHeight
        - 获取的是内容区和内边距的总大小

        offsetWidth
        offsetHeight
        - 获取的是内容区、内边距和边框的总大小

        offsetParent
        - 获取当前元素的定位父元素
        - 离当前元素最近的开启了定位的祖先元素，如果所有的祖先都没有开启定位
        则返回body

        offsetLeft
        offsetTop
        - 当前元素距离其定位父元素的距离

        scrollHeight
        scrollWidth
        - 获取元素滚动区域的大小

        注意：
        1.以上属性都是只读属性，无法修改
        2.以上属性所获取的值都是不带单位的值，可以直接参与运算

        scrollTop
        scrollLeft
        - 获取（设置）垂直和水平滚动条滚动的距离

        - 判断滚动条滚动到底：
        - 垂直：
        scrollHeight - scrollTop === clientHeight
        - 水平：
        scrollWidht - scrollLeft === clientWidth

        事件（Event）
        - 事件对象：
        - 当事件的回调函数被调用时，浏览器每次都会传递一个对象作为参数
        这个对象就是事件对象。
        - 事件对象中存储了事件相关的一切信息：
        事件触发时，哪个鼠标按键被按下、
        哪个键盘上的按键被按下、
        鼠标滚轮滚动的方向..
        - 要获取事件对象，只需在事件的回调函数中定义一个形参即可

        - 事件的冒泡（bubble）
        - 冒泡指事件的向上传导，
        子元素上事件触发时，会同时导致其祖先元素上的同类事件也被触发
        - 冒泡的存在简化了代码的编写
        - 但是有时我们不希望冒泡的存在，可以通过事件对象来取消冒泡：
        1.通过cancelBubble属性来取消冒泡
        event.cancelBubble = true;
        2.通过stopPropagation()方法来取消冒泡
        event.stopPropagation();

        - 事件的传播
        - 事件的传播分成了三个阶段：
        1.事件的捕获
        - 指事件从最外层元素开始向内部元素进行事件的捕获
        - 默认情况下，捕获阶段不会触发事件
        - 如果希望在捕获时触发事件，可以将addEventListener()的第三个参数设置为true
        2.目标元素（触发事件的元素）
        - 捕获到达目标元素停止
        3.事件的冒泡
        - 从目标元素开始向外层元素进行事件的冒泡
        - 默认情况下，冒泡时事件会被触发

        - addEventListener()
        - 为元素添加事件的响应函数
        - 参数：
        1.要绑定的事件的字符串（不要on）
        2.事件的回调函数
        3.是否在捕获阶段触发事件，默认为false
        // https://developer.mozilla.org/en-US/docs/Web/Events

        - removeEventListener()
        - 移除元素上的指定的事件
```
